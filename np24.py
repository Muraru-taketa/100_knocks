#np24.py
import re
import pandas as pd
#ここらは一緒です。
df = pd.read_json("jawiki-country.json", lines=True)
file_txt = df.query('title=="イギリス"')['text'].values[0]
ukfile = r'\[\[ファイル:([^|\]]*)'#ファイル：〜jpgみたいな説明文の表現
#ukfile = file_txt.split("\n")
for line in file_txt.split("\n"):#分割して改行
    result =re.finditer(ukfile, line)#findallマッチする部分すべてをリストで取得
    if result is None:#resultがマッチしていれば返す
        continue #fileを抽出をするためにうえのはスキップ
                 #まだファイルがただしければTrueですというだけでresultにファイル群をマッチさせて無い
    for match in result: #スキップされたらマッチするrisultを実行
        print(match.group(1))
#ukファイルの正規表現はhttps://docs.python.org/ja/3/library/re.htmlを参照
#^
#(キャレット) 文字列の先頭にマッチし、 MULTILINE モードでは各改行の直後にもマッチします。
#$
#文字列の末尾、あるいは文字列の末尾の改行の直前にマッチし、 MULTILINE モードでは改行の前にもマッチします。 
#foo は 'foo' と 'foobar' の両方にマッチしますが、正規表現 foo$ は 'foo' だけにマッチします。
#興味深いことに、 'foo1\nfoo2\n' を foo.$ で検索した場合、通常は 'foo2' だけにマッチしますが、 MULTILINE モードでは 'foo1' にもマッチします。 
#$ だけで 'foo\n' を検索した場合、2 つの (空の) マッチを見つけます: 1つは改行の直前で、もう1つは文字列の末尾です。
#*
#直前の正規表現を 0 回以上、できるだけ多く繰り返したものにマッチさせる結果の正規表現にします。
#例えば ab* は 'a'、'ab'、または 'a' に任意個数の 'b' を続けたものにマッチします。
#+
#直前の正規表現を 1 回以上繰り返したものにマッチさせる結果の正規表現にします。
#例えば ab+ は 'a' に 1 つ以上の 'b' が続いたものにマッチし、単なる 'a' にはマッチしません。
#?
#直前の正規表現を 0 回か 1 回繰り返したものにマッチさせる結果の正規表現にします。例えば ab? は 'a' あるいは 'ab' にマッチします。
#*?, +?, ??
#'*' 、 '+' 、および '?' 修飾子は全て 貪欲 (greedy) マッチで、できるだけ多くのテキストにマッチします。この挙動が望ましくない時もあります。
#例えば正規表現 <.*> が '<a> b <c>' に対してマッチされると、 '<a>' だけでなく文字列全体にマッチしてしまいます。
#修飾子の後に ? を追加すると、 非貪欲 (non-greedy) あるいは 最小 (minimal) のマッチが行われ、できるだけ 少ない 文字にマッチします。
#正規表現 <.*?> を使うと '<a>' だけにマッチします。